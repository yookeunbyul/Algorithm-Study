# 실패율

**https://school.programmers.co.kr/learn/courses/30/lessons/42889**

## 문제 설명

> 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.
>
> 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.
>
> > 실패율은 다음과 같이 정의한다.
>
> > 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
>
> 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.
>
> 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.
>
> stages의 길이는 1 이상 200,000 이하이다.
>
> stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.
>
> 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
>
> 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.

## 예제 입/출력

### 예제1

**입력**

```
5, [2, 1, 2, 6, 2, 4, 3, 3]
```

**출력**

```
[3,4,2,1,5]
```

### 예제2

**입력**

```
4, [4,4,4,4,4]
```

**출력**

```
[4,1,2,3]
```

## 접근 방식

### 시간 복잡도

-   **O(m + nlogn)**
-   O(m)은 stages 배열을 순회하며, 각 스테이지에 플레이어 수 카운트
-   O(n)은 실패율 계산해서 객체에 저장 + 최종 답 생성
-   O(nlogn)은 실패율을 기준으로 정렬 작업
-   따라서 최종 시간 복잡도는 O(m + nlogn)

### 자료구조

-   **Array, Object**
-   배열을 받아, 배열을 반환하는 문제이므로 배열 필수
-   스테이지별 실패율을 저장하기 위해 Object 사용

### 알고리즘

-   **없음**
-   단순 계산에 가까움

## 소스 코드

```javascript
function failureRate(failed, achieved) {
    return failed / achieved;
}

function valueSorted(dic) {
    return Object.entries(dic).sort((a, b) => b[1] - a[1]);
}

function answerList(dic) {
    let answer = [];
    for (i of dic) {
        answer.push(i[0] * 1);
    }
    return answer;
}

function solution(N, stages) {
    let stageFailure = {};
    let count = 0;
    let user = stages.length;
    for (let i = 1; i <= N; i++) {
        count = stages.filter((item) => item == i).length;
        stageFailure[i] = failureRate(count, user);
        user -= count;
        count = 0;
    }
    let answerDic = valueSorted(stageFailure);
    let answer = answerList(answerDic);
    return answer;
}
```
